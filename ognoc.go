package main

import (
	"crypto/sha1"
	"crypto/sha512"
	"flag"
	"fmt"
	"math"
	"math/rand"
	"strings"
	"time"
	"unicode"

	"github.com/i0Ek3/color"
	"golang.org/x/crypto/sha3"
)

const (
	alphabets = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	numbers   = "0123456789"
	specials  = "!@#$%&*()_+-=?.,:;<>"

	plaintext = "aBcDefGhi"
	algoType  = "SHA224"
	offset    = 2
	pwdLen    = 12
	content   = "spechar"
	where     = "inner"
	showColor = "yellow"
)

// type F indicates a function which returns a string
type F func(string, int) string

// Caesar calls FormatString to format given string and
// calls caesar to process the specific logical code
func Caesar(plaintext string, offset int) (res string) {
	strs := FormatString(plaintext)
	if offsetCheck(strs, offset) {
		res = caesar(strs, offset)
	} else {
		offset = randomN(len(strs))
		res = caesar(strs, offset)
	}
	return
}

// caesar returns the transformed string by given offset
func caesar(plaintext string, offset int) string {
	str := stringToRunes(plaintext)
	alp := stringToRunes(alphabets)

	if offset >= 0 {
		for i := 0; i < len(plaintext); i++ {
			str[i] = alp[i+offset]
		}
	} else {
		for i := len(plaintext) - 1; i > 0; i-- {
			n := i - int(math.Abs(float64(offset)))
			str[i] = alp[n]
		}
	}
	return string(str)
}

// stringToRunes returns a []rune to make given string
// modifiable and ignores strings' immutable feature
func stringToRunes(strs string) []rune {
	str := []rune(strs)
	return str
}

// runesToString converts []rune to string
func runesToString(runes []rune) (res string) {
	for _, v := range runes {
		res += string(v)
	}
	return
}

// Transform calls splitCipher to split given cipher with length n
func Transform(cipher, algoType string, ns ...int) string {
	n := getLen(algoType, plaintext)
	if offsetCheck(cipher, n) {
		return splitCipher(algoType, cipher, n)
	} else {
		return splitCipher(algoType, cipher, len(cipher))
	}
}

// stringToBytes converts the given string into []byte
func stringToBytes(str string) []byte {
	return []byte(str)
}

// getLen returns the cipher's length which generated by given algorithm
func getLen(algoType, cipher string) (l int) {
	if algoType != "" {
		switch algoType {
		case "SHA1":
			l = len(sha1.Sum(stringToBytes(cipher))) - 1
		case "SHA224":
			l = len(sha3.Sum224(stringToBytes(cipher))) - 1
		case "SHA256":
			l = len(sha3.Sum256(stringToBytes(cipher))) - 1
		case "SHA384":
			l = len(sha3.Sum384(stringToBytes(cipher))) - 1
		case "SHA512":
			l = len(sha512.Sum512(stringToBytes(cipher))) - 1
		case "SHA512_224":
			l = len(sha512.Sum512_224(stringToBytes(cipher))) - 1
		case "SHA512_256":
			l = len(sha512.Sum512_256(stringToBytes(cipher))) - 1
		}
	} else {
		l = randomN(len(cipher))
	}
	return
}

// splitCipher returns a splited string which generated by given algorithms,
// argument n means how many characters would you like to return
func splitCipher(algoType, cipher string, n int) (res string) {
	if algoType != "" {
		switch algoType {
		case "SHA1":
			var b20 [20]byte
			b20 = sha1.Sum(stringToBytes(cipher))
			res = string(b20[:n])
		case "SHA224":
			var b28 [28]byte
			b28 = sha3.Sum224(stringToBytes(cipher))
			res = string(b28[:n])
		case "SHA256":
			var b32 [32]byte
			b32 = sha3.Sum256(stringToBytes(cipher))
			res = string(b32[:n])
		case "SHA384":
			var b48 [48]byte
			b48 = sha3.Sum384(stringToBytes(cipher))
			res = string(b48[:n])
		case "SHA512":
			var b512 [sha512.Size]byte
			b512 = sha512.Sum512(stringToBytes(cipher))
			res = string(b512[:n])
		case "SHA512_224":
			var b224 [sha512.Size224]byte
			b224 = sha512.Sum512_224(stringToBytes(cipher))
			res = string(b224[:n])
		case "SHA512_256":
			var b256 [sha512.Size256]byte
			b256 = sha512.Sum512_256(stringToBytes(cipher))
			res = string(b256[:n])
		}
	} else {
		res = cipher[:n]
	}
	return
}

// randomN returns a random number in a given interval (0, length)
func randomN(length int) int {
	rand.Seed(time.Now().UnixNano())
	return rand.Intn(length)
}

// getN returns a int number in given arguments
func getN(length int, ns ...int) (n int) {
	if len(ns) > 0 {
		n = ns[0]
	} else {
		n = randomN(length)
	}
	return
}

// CommonT returns a transformed string in given functions,
// different policy represents different transformed functions,
// argument ns represents transform correspoding characters
// every ns times
func CommonT(plaintext, policy string, ns ...int) (res string) {
	strs := FormatString(plaintext)

	//n := getN(len(strs), ns[0])
	n := randomN(len(strs))

	switch policy {
	case "low":
		res = lowUp(strs, n)
	case "up":
		res = upLow(strs, n)
	case "spec":
		res = special(strs, n)
	}
	return
}

// FormatString formats the give string
func FormatString(str string) string {
	return removeNonstr(str)
}

// removeNonstr removes the non-string characters and lowcase then
func removeNonstr(str string) string {
	res := ""
	s := stringToRunes(str)
	for i := 0; i < len(str); i++ {
		if unicode.IsLetter(s[i]) {
			res += string(s[i])
		}
	}
	return strings.ToLower(res)
}

// offsetCheck checks if offset's length bigger than given string
func offsetCheck(given string, offset int) bool {
	return int(math.Abs(float64(offset))) < len(given)
}

// lowUp upcases the given string accroding offset, while offset = 2,
// the string abcdefg => aBcDeFg, while offset = 3, abcdefg => abCdeFg
func lowUp(str string, offset int) string {
	res := ""
	for i := 0; i < len(str); i++ {
		if (i+1)%offset == 0 {
			res += strings.ToUpper(string(str[i]))
		} else {
			res += strings.ToLower(string(str[i]))
		}
	}
	if len(res) < pwdLen {
		res = FormatN(res, content, where, pwdLen-len(res))
	}
	return res
}

// upLow lowcases the given string accroding to offset, while offset = 2,
// the string abcdefg => AbCdEfG, while offset = 3, abcdefg => AbcDefG
func upLow(str string, offset int) string {
	res := ""
	for i := 0; i < len(str); i++ {
		if (i+1)%offset == 0 {
			res += strings.ToLower(string(str[i]))
		} else {
			res += strings.ToUpper(string(str[i]))
		}
	}
	if len(res) < pwdLen {
		res = FormatN(res, content, where, pwdLen-len(res))
	}
	return res
}

// special specializes the given string accroding to offset
func special(str string, offset int) string {
	res := ""
	for i := 0; i < len(str); i++ {
		if (i+1)%offset == 0 {
			res += runeToSpechar(rune(str[i]))
		} else {
			res += string(str[i])
		}
	}
	if len(res) < pwdLen {
		res = FormatN(res, content, where, pwdLen-len(res))
	}
	return res
}

// FormatN formats the given string into a new string
// which length is n, the recommend range of n is [10, 14]
func FormatN(str, content, where string, n int) (newstr string) {
	if len(str) < n {
		newstr = fillN(str, content, where, n-len(str))
	} else if len(str) > n {
		newstr = cutN(str, where, len(str)-n)
	} else {
		newstr = str
	}
	return
}

// fillN fills the given content into str according where with length n
func fillN(str, content, where string, n int) string {
	if content == "number" {
		return fillNumber(str, where, n)
	} else if content == "spechar" {
		return fillSpechar(str, where, n)
	} else if content == "letter" {
		return fillLetter(str, where, n)
	} else {
		return fmt.Sprintf("Unexpected content!")
	}
}

// fill position: pre, post, in, use an algorithm to choose
// which position should be take in fillX function
//func selectOne(n int) {}

//func where(str, where string) F {}
// TODO: abstract where function

// fillNumber fills the n random numbers into str accroding to
// where, and then return the result. The specified content
// is not accepted temporarily
func fillNumber(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(numbers[randomN(len(numbers))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(numbers[randomN(len(numbers))])
		}
		l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(numbers[randomN(len(numbers))])
		}
	}
	return str
}

// fillSpechar fills the n random special characters into str
// accroding where, and then return the result
func fillSpechar(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(specials[randomN(len(specials))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(specials[randomN(len(specials))])
		}
		l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(specials[randomN(len(specials))])
		}
	}
	return str
}

// fillLetter fills the n random letters into str accroding
// where, and then return the result
func fillLetter(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(alphabets[randomN(len(alphabets))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(alphabets[randomN(len(alphabets))])
		}
		l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(alphabets[randomN(len(alphabets))])
		}
	}
	return str
}

// cutN cuts the n characters from the given str accroding where,
// and then return the result
func cutN(str, where string, n int) string {
	switch where {
	case "pre":
		str = str[n:]
	case "inner":
		str = str[:n] + str[n*2:]
	case "post":
		str = str[:len(str)-n]
	}
	return str
}

// runeToSpechar specializes the like-char characters into
// special characters, and then return the result. For example,
// i,j => !, a => @
func runeToSpechar(r rune) string {
	switch r {
	case 'a', 'c':
		return "@"
	case 'i', 'j':
		return "!"
	case 'p':
		return "+"
	case 'x':
		return "*"
	case 'b':
		return "6"
	case 'e', 'l':
		return "1"
	case 'g', 'q':
		return "9"
	case 'o':
		return "0"
	case 'r', 'z':
		return "2"
	case 's':
		return "5"
	default:
		return string(r)
	}
}

func colored(colorName string, str ...string) string {
	switch colorName {
	case "white":
		return color.White(str...)
	case "black":
		return color.Black(str...)
	case "green":
		return color.Green(str...)
	case "yellow":
		return color.Yellow(str...)
	case "red":
		return color.Red(str...)
	case "cyan":
		return color.Cyan(str...)
	case "magenta":
		return color.Magenta(str...)
	default:
		//return color.Red("No color offered!")
		return color.Blue(str...)
	}
}

func Generate(plaintext, position, fill, c string, num, length int) string {
	cipher := Caesar(plaintext, num)
	return colored(c, FormatN(cipher, fill, position, length))
}

// GenerateRandom generates the random cipher with ungiven string
func GenerateRandom(c string, length int) string {
	// TODO
	return ""
}

// Detect detects the complicated of cipher by easy scoring mechanism
func Detect(result string) string {
	a := scoreByLen(result)
	b := scoreByLetter(result)
	c := scoreBySpechar(result)
	d := scoreByNumber(result)
	e := reward(result)
	score := a + b + c + d + e

	difficult := ""
	switch {
	case score >= 90 && score <= 100:
		difficult = "VERY_SECURE"
	case score >= 80 && score < 90:
		difficult = "SECURE"
	case score >= 70 && score < 80:
		difficult = "VERY_STRONG"
	case score >= 60 && score < 70:
		difficult = "STRONG"
	case score >= 50 && score < 60:
		difficult = "AVERAGE"
	case score >= 25 && score < 50:
		difficult = "WEAK"
	case score >= 0 && score < 25:
		difficult = "VERY_WEAK"
	}
	return difficult
}

func scoreByLen(result string) (score int) {
	n := len(result)
	switch {
	case n <= 4:
		score = 5
	case n > 5 && n <= 7:
		score = 10
	case n >= 8:
		score = 25
	}
	return
}

func scoreByLetter(result string) (score int) {
	len1, len2 := calLetter(result)
	n := len1 + len2
	if n <= 0 {
		score = 0
	} else if len1 == 0 || len2 == 0 {
		score = 10
	} else {
		score = 20
	}
	return
}

func scoreBySpechar(result string) (score int) {
	n := calChar(result)
	switch {
	case n == 0:
		score = 0
	case n == 1:
		score = 10
	case n > 1:
		score = 25
	}
	return
}

func scoreByNumber(result string) (score int) {
	n := calNumber(result)
	switch {
	case n == 0:
		score = 0
	case n == 1:
		score = 10
	case n > 1:
		score = 20
	}
	return
}

func reward(result string) (score int) {
	l1, l2 := calLetter(result)
	l := l1 + l2
	num := calNumber(result)
	ch := calChar(result)

	if l != 0 && num != 0 {
		score = 2
	} else if l != 0 && num != 0 && ch != 0 {
		score = 3
	} else if l1 != 0 && l2 != 0 && num != 0 && ch != 0 {
		score = 5
	}
	return
}

func calNumber(result string) int {
	num := 0
	for _, v := range result {
		if v >= '0' && v <= '9' {
			num++
		}
	}
	return num
}

func calChar(result string) int {
	num := 0
	for _, v1 := range result {
		for _, v2 := range specials {
			if v1 == v2 {
				num++
			}
		}
	}
	return num
}

func calLetter(result string) (int, int) {
	len1, len2 := 0, 0
	for _, v := range result {
		if v >= 'a' && v <= 'z' {
			len1++
		}

		if v >= 'A' && v <= 'Z' {
			len2++
		}
	}
	return len1, len2
}

var (
	l, n    *int
	p, f, c *string
)

func init() {
	l = flag.Int("l", pwdLen, "the length of generated password")
	n = flag.Int("n", offset, "the offset you want to move")
	p = flag.String("p", where, "specific the position to insert(pre, inner, post)")
	f = flag.String("f", content, "the base fill content(number, letter, spechar)")
	c = flag.String("c", showColor, "the color of generate password(black, white, blue, red, yellow, green, cyan, magenta)")
}

func main() {
	flag.Parse()

	fmt.Println(Generate(plaintext, *p, *f, *c, *n, *l))
}
