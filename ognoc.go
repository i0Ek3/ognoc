package main

import (
	"fmt"
    "flag"
	"crypto/sha1"
	"crypto/sha512"
	"math"
	"math/rand"
	"strings"
	"time"
	"unicode"

    "golang.org/x/crypto/sha3"
    "github.com/i0Ek3/color"
)

var (
	alphabets = "abcdefghijklmnopqrstuvwxyz"
	numbers   = "012345679"
	specials  = "!@#$%^&*()_+-=[]{}<>?.|"

	plaintext = "aBcDefGhi"
    algoType  = "SHA224"
	offset    = 2
	pwdLen    = 12
    content   = "spechar"
    where     = "inner"
    showColor = "yellow"
)

// type F indicates a function which returns a string
type F func(string, int) string

// Caesar calls FormatString to format given string and
// calls caesar to process the specific logical code
func Caesar(plaintext string, offset int) (res string) {
	strs := FormatString(plaintext)
	if offsetCheck(strs, offset) {
		res = caesar(strs, offset)
	} else {
		offset = randomN(len(strs))
		res = caesar(strs, offset)
	}
	return
}

// caesar returns the transformed string by given offset
func caesar(plaintext string, offset int) string {
	str := stringToRunes(plaintext)
	alp := stringToRunes(alphabets)

	if offset >= 0 {
		for i := 0; i < len(plaintext); i++ {
			str[i] = alp[i+offset]
		}
	} else {
		for i := len(plaintext) - 1; i > 0; i-- {
			n := i - int(math.Abs(float64(offset)))
			str[i] = alp[n]
		}
	}
	return string(str)
}

// stringToRunes returns a []rune to make given string
// modifiable and ignores strings' immutable feature
func stringToRunes(strs string) []rune {
	str := []rune(strs)
	return str
}

// runesToString converts []rune to string
func runesToString(runes []rune) (res string) {
    for _, v := range runes {
        res += string(v)
    }
    return
}

// Transform calls splitCipher to split given cipher with length n
func Transform(cipher, algoType string, ns ...int) string {
    n := getLen(algoType, plaintext)
	if offsetCheck(cipher, n) {
		return splitCipher(algoType, cipher, n)
	} else {
		return splitCipher(algoType, cipher, len(cipher))
	}
}

// stringToBytes converts the given string into []byte
func stringToBytes(str string) []byte {
    return []byte(str)
}

// getLen returns the cipher's length which generated by given algorithm
func getLen(algoType, cipher string) (l int) {
    if algoType != "" {
	    switch algoType {
	    case "SHA1":
	        l = len(sha1.Sum(stringToBytes(cipher))) - 1
	    case "SHA224":
	        l = len(sha3.Sum224(stringToBytes(cipher))) - 1
	    case "SHA256":
	        l = len(sha3.Sum256(stringToBytes(cipher))) - 1
	    case "SHA384":
	        l = len(sha3.Sum384(stringToBytes(cipher))) - 1
	    case "SHA512":
	        l = len(sha512.Sum512(stringToBytes(cipher))) - 1
	    case "SHA512_224":
	        l = len(sha512.Sum512_224(stringToBytes(cipher))) - 1
	    case "SHA512_256":
	        l = len(sha512.Sum512_256(stringToBytes(cipher))) - 1
	    }
    } else {
        l = randomN(len(cipher))
    }
    return
}

// splitCipher returns a splited string which generated by given algorithms,
// argument n means how many characters would you like to return
func splitCipher(algoType, cipher string, n int) (res string) {
	if algoType != "" {
	    switch algoType {
	    case "SHA1":
            var b20 [20]byte
	        b20 = sha1.Sum(stringToBytes(cipher))
            res = string(b20[:n])
	    case "SHA224":
            var b28 [28]byte
	        b28 = sha3.Sum224(stringToBytes(cipher))
            res = string(b28[:n])
	    case "SHA256":
            var b32 [32]byte
	        b32 = sha3.Sum256(stringToBytes(cipher))
            res = string(b32[:n])
	    case "SHA384":
            var b48 [48]byte
	        b48 = sha3.Sum384(stringToBytes(cipher))
            res = string(b48[:n])
	    case "SHA512":
            var b512 [sha512.Size]byte
	        b512 = sha512.Sum512(stringToBytes(cipher))
            res = string(b512[:n])
	    case "SHA512_224":
            var b224 [sha512.Size224]byte
	        b224 = sha512.Sum512_224(stringToBytes(cipher))
            res = string(b224[:n])
	    case "SHA512_256":
            var b256 [sha512.Size256]byte
	        b256 = sha512.Sum512_256(stringToBytes(cipher))
            res = string(b256[:n])
	    }
    } else {
		res = cipher[:n]
    }
	return
}

// randomN returns a random number in a given interval (0, length)
func randomN(length int) int {
	rand.Seed(time.Now().UnixNano())
	return rand.Intn(length)
}

// getN returns a int number in given arguments
func getN(length int, ns ...int) (n int) {
	if len(ns) > 0 {
		n = ns[0]
	} else {
		n = randomN(length)
	}
	return
}

// CommonT returns a transformed string in given functions,
// different policy represents different transformed functions,
// argument ns represents transform correspoding characters
// every ns times 
func CommonT(plaintext, policy string, ns ...int) (res string) {
	strs := FormatString(plaintext)

	//n := getN(len(strs), ns[0])
	n := randomN(len(strs))

	switch policy {
	case "low":
		res = lowUp(strs, n)
	case "up":
		res = upLow(strs, n)
	case "spec":
		res = special(strs, n)
	}
	return
}

// FormatString formats the give string
func FormatString(str string) string {
	return removeNonstr(str)
}

// removeNonstr removes the non-string characters and lowcase then
func removeNonstr(str string) string {
	res := ""
	s := stringToRunes(str)
	for i := 0; i < len(str); i++ {
		if unicode.IsLetter(s[i]) {
			res += string(s[i])
		}
	}
	return strings.ToLower(res)
}

// offsetCheck checks if offset's length bigger than given string
func offsetCheck(given string, offset int) bool {
	if int(math.Abs(float64(offset))) < len(given) {
		return true
	}
	return false
}

// lowUp upcases the given string accroding offset, while offset = 2,
// the string abcdefg => aBcDeFg, while offset = 3, abcdefg => abCdeFg
func lowUp(str string, offset int) string {
    res := ""
	for i := 0; i < len(str); i++ {
        if (i+1) % offset == 0 {
		    res += strings.ToUpper(string(str[i]))
        } else {
		    res += strings.ToLower(string(str[i]))
        }
    }
    if len(res) < pwdLen {
        res = FormatN(res, content, where, pwdLen - len(res))
    }
	return res
}

// upLow lowcases the given string accroding to offset, while offset = 2,
// the string abcdefg => AbCdEfG, while offset = 3, abcdefg => AbcDefG
func upLow(str string, offset int) string {
    res := ""
	for i := 0; i < len(str); i++ {
        if (i+1) % offset == 0 {
		    res += strings.ToLower(string(str[i]))
        } else {
            res += strings.ToUpper(string(str[i]))
        }
	}
    if len(res) < pwdLen {
        res = FormatN(res, content, where, pwdLen - len(res))
    }
	return res
}

// special specializes the given string accroding to offset
func special(str string, offset int) string {
    res := ""
	for i := 0; i < len(str); i++ {
        if (i+1) % offset == 0 {
		    res += runeToSpechar(rune(str[i]))
        } else {
            res += string(str[i])
        }
	}
    if len(res) < pwdLen {
        res = FormatN(res, content, where, pwdLen - len(res))
    }
	return res
}

// FormatN formats the given string into a new string
// which length is n, the recommend range of n is [10, 14]
func FormatN(str, content, where string, n int) (newstr string) {
	if len(str) < n {
		newstr = fillN(str, content, where, n-len(str))
	} else if len(str) > n {
		newstr = cutN(str, where, len(str)-n)
	} else {
		newstr = str
	}
	return
}

// fillN fills the given content into str according where with length n
func fillN(str, content, where string, n int) string {
	if content == "number" {
		return fillNumber(str, where, n)
	} else if content == "spechar" {
		return fillSpechar(str, where, n)
	} else if content == "letter" {
		return fillLetter(str, where, n)
	} else {
		return fmt.Sprintf("Unexpected content!")
	}
}

// fill position: pre, post, in, use an algorithm to choose
// which position should be take in fillX function
//func selectOne(n int) {}

//func where(str, where string) F {}
// TODO: abstract where function

// fillNumber fills the n random numbers into str accroding to
// where, and then return the result. The specified content
// is not accepted temporarily
func fillNumber(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(numbers[randomN(len(numbers))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(numbers[randomN(len(numbers))])
		}
        l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(numbers[randomN(len(numbers))])
		}
	}
	return str
}

// fillSpechar fills the n random special characters into str
// accroding where, and then return the result
func fillSpechar(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(specials[randomN(len(specials))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(specials[randomN(len(specials))])
		}
        l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(specials[randomN(len(specials))])
		}
	}
	return str
}

// fillLetter fills the n random letters into str accroding
// where, and then return the result
func fillLetter(str, where string, n int) string {
	strs := ""
	switch where {
	case "pre":
		for i := 0; i < n; i++ {
			str = string(alphabets[randomN(len(alphabets))]) + str
		}
	case "inner":
		for i := 0; i < n; i++ {
			strs += string(alphabets[randomN(len(alphabets))])
		}
        l := randomN(len(str))
		str = str[:l] + strs + str[len(str)-l:]
	case "post":
		for i := 0; i < n; i++ {
			str += string(alphabets[randomN(len(alphabets))])
		}
	}
	return str
}

// cutN cuts the n characters from the given str accroding where,
// and then return the result
func cutN(str, where string, n int) string {
	switch where {
	case "pre":
		str = str[n:]
	case "inner":
		str = str[:n] + str[n*2:]
	case "post":
		str = str[:len(str)-n]
	}
	return str
}

// runeToSpechar specializes the like-char characters into
// special characters, and then return the result. For example,
// i,j => !, a => @
func runeToSpechar(r rune) string {
	switch r {
	case 'a', 'c':
		return "@"
	case 'i', 'j':
		return "!"
	case 'p':
		return "+"
	case 'x':
		return "*"
	case 'b':
		return "6"
	case 'e', 'l':
		return "1"
	case 'g', 'q':
		return "9"
	case 'o':
		return "0"
	case 'r', 'z':
		return "2"
	case 's':
		return "5"
	default:
		return string(r)
	}
}

func colored(colorName string, str ...string) string {
    switch colorName {
    case "white":
        return color.White(str...)
    case "black":
        return color.Black(str...)
    case "green":
        return color.Green(str...)
    case "yellow":
        return color.Yellow(str...)
    case "red":
        return color.Red(str...)
    case "cyan":
        return color.Cyan(str...)
    case "magenta":
        return color.Magenta(str...)
    default:
        //return color.Red("No color offered!")
        return color.Blue(str...)
    }
}

func Generate(plaintext, position, fill, c string, num, length int) string {
    cipher := Caesar(plaintext, num)
    return colored(c, FormatN(cipher, fill, position, length))
}

// GenerateRandom generates the random cipher with ungiven string
func GenerateRandom(c string, length int) string {
    // TODO
    return ""
}

// Detect detects the complicated of cipher by entropy and regex,
// and return the percentage of complicated or unavailable.
func Detect(result string) string {
    // TODO
    return ""
}

var (
    l, n    *int
    p, f, c *string
)

func init() {
    l = flag.Int("l", pwdLen, "the length of generated password")
    n = flag.Int("n", offset, "the offset you want to move")
    p = flag.String("p", where, "specific the position to insert(pre, inner, post)")
    f = flag.String("f", content, "the base fill content(number, letter, spechar)")
    c = flag.String("c", showColor, "the color of generate password(black, white, blue, red, yellow, green, cyan, magenta)")
}

func main() {
    flag.Parse()

    fmt.Println(Generate(plaintext, *p, *f, *c, *n, *l))
}
